<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Grand Radiance of Hypnocy</title>
<style>
  body {
    margin: 0;
    background-color: #111;
    color: #ccc;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
  }
  canvas {
    background: #000;
    border: 2px solid #444;
    display: block;
    margin-bottom: 20px;
  }
  select, button {
    margin: 5px;
    padding: 10px 20px;
    background: #222;
    color: #ccc;
    border: 1px solid #555;
    cursor: pointer;
  }
  select:focus, button:focus {
    outline: none;
    border-color: #888;
  }
</style>
</head>
<body>
  <canvas id="hypnoCanvas" width="800" height="600"></canvas>
  <div>
    <select id="moodSelect">
      <option value="calm">Calm</option>
      <option value="hunger">Hunger</option>
      <option value="focus">Focus</option>
      <option value="creativity">Creativity</option>
      <option value="unease">Unease</option>
    </select>
    <button id="startBtn">Start</button>
    <button id="recordBtn" disabled>Start Recording</button>
  </div>
  <video id="audioCarrier" width="1" height="1" style="position:absolute;opacity:0;" playsinline></video>
<script>
const canvas = document.getElementById('hypnoCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const recordBtn = document.getElementById('recordBtn');
const moodSelect = document.getElementById('moodSelect');
const audioCarrier = document.getElementById('audioCarrier');

let audioCtx, gainNode, oscillatorL, oscillatorR;
let recording = false;
let mediaRecorder, recordedChunks = [];
let animationId, startTime;

const moods = {
  calm:   {colors:["#003366","#005599","#3399cc"], shape:"blobs", freq:8}, // alpha
  hunger: {colors:["#ff0000","#ff6600","#ffaa00"], shape:"circles", freq:14}, // beta
  focus:  {colors:["#00ffcc","#00aaff","#004477"], shape:"figure8", freq:12}, // low beta
  creativity:{colors:["#9933ff","#ff33cc","#66ffff"], shape:"spiral", freq:6}, // theta
  unease: {colors:["#330000","#660000","#990000"], shape:"jitter", freq:18} // near infrasound
};

function initAudio(moodKey) {
  if (audioCtx) audioCtx.close();
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  const baseFreq = 200; // carrier tone
  const beat = moods[moodKey].freq;

  const merger = audioCtx.createChannelMerger(2);
  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0.1;

  oscillatorL = audioCtx.createOscillator();
  oscillatorR = audioCtx.createOscillator();
  oscillatorL.frequency.value = baseFreq - beat/2;
  oscillatorR.frequency.value = baseFreq + beat/2;

  oscillatorL.connect(merger, 0, 0);
  oscillatorR.connect(merger, 0, 1);
  merger.connect(gainNode).connect(audioCtx.destination);

  oscillatorL.start();
  oscillatorR.start();
}

function drawPattern(moodKey, time) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const mood = moods[moodKey];
  const t = time/1000;

  switch(mood.shape) {
    case "blobs":
      for (let i=0; i<5; i++) {
        ctx.fillStyle = mood.colors[i % mood.colors.length];
        const x = canvas.width/2 + Math.sin(t+i)*150;
        const y = canvas.height/2 + Math.cos(t*0.5+i)*100;
        ctx.beginPath();
        ctx.arc(x,y,80+20*Math.sin(t+i),0,Math.PI*2);
        ctx.fill();
      }
      break;
    case "circles":
      for (let i=0; i<7; i++) {
        ctx.strokeStyle = mood.colors[i % mood.colors.length];
        ctx.lineWidth = 4;
        const r = 50 + 40*i + 10*Math.sin(t*2+i);
        ctx.beginPath();
        ctx.arc(canvas.width/2, canvas.height/2, r, 0, Math.PI*2);
        ctx.stroke();
      }
      break;
    case "figure8":
      ctx.strokeStyle = mood.colors[0];
      ctx.lineWidth = 6;
      ctx.beginPath();
      for (let a=0; a<Math.PI*2; a+=0.01) {
        const x = canvas.width/2 + Math.sin(a*2+t)*200*Math.cos(a);
        const y = canvas.height/2 + Math.sin(a)*100;
        a===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
      }
      ctx.stroke();
      break;
    case "spiral":
      ctx.strokeStyle = mood.colors[1];
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let a=0; a<Math.PI*10; a+=0.1) {
        const r = 20 + a*5;
        const x = canvas.width/2 + Math.cos(a+t*0.5)*r;
        const y = canvas.height/2 + Math.sin(a+t*0.5)*r;
        a===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
      }
      ctx.stroke();
      break;
    case "jitter":
      for (let i=0; i<100; i++) {
        ctx.fillStyle = mood.colors[Math.floor(Math.random()*mood.colors.length)];
        const x = Math.random()*canvas.width;
        const y = Math.random()*canvas.height;
        ctx.fillRect(x,y,5,5);
      }
      break;
  }
}

function startHypnosis() {
  const mood = moodSelect.value;
  initAudio(mood);

  const animate = (timestamp) => {
    drawPattern(mood, timestamp);
    animationId = requestAnimationFrame(animate);
  };
  animationId = requestAnimationFrame(animate);
  recordBtn.disabled = false;
}

function startRecording() {
  const stream = canvas.captureStream(30);
  const audioStream = audioCtx.createMediaStreamDestination();
  gainNode.connect(audioStream);
  const combined = new MediaStream([...stream.getVideoTracks(), ...audioStream.stream.getAudioTracks()]);

  mediaRecorder = new MediaRecorder(combined);
  recordedChunks = [];

  mediaRecorder.ondataavailable = e => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'hypno_video.webm';
    a.click();
  };

  mediaRecorder.start();
  recordBtn.textContent = "Stop Recording";
  recording = true;

  setTimeout(() => {
    if (recording) stopRecording();
  }, 3600000); // 1 hour max
}

function stopRecording() {
  mediaRecorder.stop();
  recording = false;
  recordBtn.textContent = "Start Recording";
}

startBtn.addEventListener('click', startHypnosis);
recordBtn.addEventListener('click', () => {
  recording ? stopRecording() : startRecording();
});
</script>
</body>
</html>
